---
title: "Cleaning Data: Case Studies"
author: "Steve Newns"
date: "December 5, 2017"
output: html_document
---

# Ticket Sales

```{r}
sales <- read.csv("sales.csv", stringsAsFactors = F)
# View dimensions of sales
dim(sales)

# Inspect first 6 rows of sales
head(sales)

# View column names of sales
names(sales)
```

 rows appear to represent individual purchases and the columns contain different pieces of information about each purchase. 
 
```{r}
 # Look at structure of sales
str(sales)

# View a summary of sales
summary(sales)

# Load dplyr
library(dplyr)

# Get a glimpse of sales
glimpse(sales)

# Remove the first column (just a duplication of the row numbers)  of sales: sales2
sales2 <- sales[,-1]
```
 
# Information not worth keeping

Many of the columns have information that's of no use to us. For example, the first four columns contain internal codes representing particular events. The last fifteen columns also aren't worth keeping; there are too many missing values to make them worthwhile.

An easy way to get rid of unnecessary columns is to create a vector containing the column indices you want to keep, then subset the data based on that vector using single bracket subsetting.
Instructions
100xp

    Create a vector called keep that contains the indices of the columns you want to save. Remember: you want to keep everything besides the first 4 and last 15 columns of sales2.
    Subset the columns of sales2 using your vector and assign the result to sales3.
```{r}
## sales2 is available in your workspace

# Define a vector of column indices: keep = 1st 4 cols = internal codes, last 15 cols = too many missing valuesa
keep <- c(5:(length(sales2) - 15))

# Subset sales2 using keep: sales3
sales3 <- sales2[,keep]
```

## Separating columns

Some of the columns in your data frame include multiple pieces of information that should be in separate columns. In this exercise, you will separate such a column into two: one for date and one for time. You will use the separate() function from the tidyr package (already installed for you).

Take a look at the event_date_time column by typing head(sales3$event_date_time) in the console. You'll notice that the date and time are separated by a space. Therefore, you'll use sep = " " as an argument to separate().
Instructions
100xp

    Load the tidyr package.
    Split the event_date_time column of sales3 into "event_dt" and "event_time". Assign the result to sales4.
    Split the sales_ord_create_dttm column of sales4 into "ord_create_dt" and "ord_create_time". Assign the result to sales5.
```{r}
## sales3 is pre-loaded in your workspace

# Load tidyr
library(tidyr)

# split the date-time cols = event_date_time + sales_ord_create_dttm

# Split event_date_time: sales4
sales4 <- separate(sales3, event_date_time, into = c("event_dt", "event_time"), sep = " ")

# Split sales_ord_create_dttm: sales5
sales5 <- separate(sales4, sales_ord_create_dttm, into = c("ord_create_dt", "ord_create_time"), sep = " ")
```

## Dealing with warnings

Looks like that second call to separate() threw a warning. Not to worry; warnings aren't as bad as error messages. It's not saying that the command didn't execute; it's just a heads-up that something unusual happened.

The warning says Too few values at 4 locations. You may be able to guess already what the issue is, but it's still good to take a look.

The locations (i.e. rows) given in the warning are 2516, 3863, 4082, and 4183. Have a look at the contents of the sales_ord_create_dttm column in those rows.
Instructions
100xp

    Assign a vector issues that contains the indices of the four troublesome rows: 2516, 3863, 4082, and 4183.
    Subset sales3$sales_ord_create_dttm to look at these observations. Remember to use sales3 (not sales4), since you want the data frame from before you separated columns!
    For comparison, print element 2517 of sales3$sales_ord_create_dttm, which did not cause a warning
```{r}
# Define an issues vector
issues <- c(2516,3863,4082,4183)

# Print values of sales_ord_create_dttm at these indices
sales3$sales_ord_create_dttm[issues] # NULL values

# Print a well-behaved value of sales_ord_create_dttm
sales3$sales_ord_create_dttm[2517]    
```

The warning was just because of four missing values. You'll ignore them for now, but if your analysis depended on complete date/time information, you would probably need to delete those rows.

# MBTA Ridership Data

## Using readxl

The Massachusetts Bay Transportation Authority ("MBTA" or just "the T" for short) manages America's oldest subway, as well as Greater Boston's commuter rail, ferry, and bus systems.

It's your first day on the job as the T's data analyst and you've been tasked with analyzing average ridership through time. You're in luck, because this chapter of the course will guide you through cleaning a set of MBTA ridership data!

The dataset is stored as an Excel spreadsheet called mbta.xlsx in your working directory. You'll use the read_excel() function from Hadley Wickham's readxl package to import it.

The first time you import a dataset, you might not know how many rows need to be skipped. In this case, the first row is a title (see this Excel screenshot), so you'll need to skip the first row. You can also download the whole Excel spreadsheet here.
Instructions
100xp

    Load the readxl package.
    Import the ridership data using read_excel(). Set the skip argument to 1 and store the result to mbta.
```{r}
# Load readxl
library(readxl)

# Import mbta.xlsx and skip first row: mbta
mbta <- read_excel("mbta.xlsx", skip = 1)

str(mbta)

# View the first 6 rows of mbta
head(mbta)

# View a summary of mbta
summary(mbta)
```

## Removing unnecessary rows and columns

It appears that the data are organized with observations stored as columns rather than as rows. You can fix that.

First, though, you can address the missing data. All of the NA values are stored in the All Modes by Qtr row. This row really belongs in a different data frame; it is a quarterly average of weekday MBTA ridership. Since this dataset tracks monthly average ridership, you'll remove that row.

Similarly, the 7th row (Pct Chg / Yr) and the 11th row (TOTAL) are not really observations as much as they are analysis. Go ahead and remove the 7th and 11th rows as well.

The first column also needs to be removed because it's just listing the row numbers.

In case you were wondering, this dataset is stored as a tibble which is just a specific type of data frame. For more information, see here.
Instructions
100xp

    Remove the first, seventh, and eleventh rows of mbta (All Modes By Qtr, Pct Chg / Yr, and TOTAL). Name the resulting data frame mbta2.
    Remove the first column of mbta2. Name the resulting data frame mbta3.
```{r}
# Remove rows 1, 7, and 11 of mbta: mbta2
mbta2 <- mbta[-c(1,7,11),]

# Remove the first column of mbta2: mbta3
mbta3 <- mbta2[,-c(1)]
```