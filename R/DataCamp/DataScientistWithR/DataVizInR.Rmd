---
title: "DataVizInR"
author: "Steve Newns"
date: "November 29, 2017"
output: html_document
---

```{r}
library(MASS)
library(car)
library(wordcloud)
```
`matplot()` can be used to easily generate a plot w/ several scatterplots on the same set of axes. By default, the points in these scatterplots are represented by the numbers 1 through n, where n = the total number of scatterplots included, but most of options available w/ `plot()` are also possible by specifying the appropriate arguments.

Set up a plot array w/ 4 of these multiple scatterplot displays, each including 1 more scatterplot than the previous one + judge for yourself how many scatterplots is too many.

    Use the par() function to set up the mfrow parameter to generate a two-by-two plot array.
    Use the matplot() function to construct a two-scatterplot display of
    protein and fat versus calories. Give this plot the title "Two scatterplots" using the title() function. Label the x-axis "calories" and the y-axis "" to get rid of the default y-axis label.
    protein, fat and fibre versus calories. Give this plot the title "Three scatterplots". Similarly, label the x-axis "calories" and the y-axis "".
    protein, fat, fibre and carbo versus calories. Give this plot the title "Four scatterplots". Again, label the x-axis "calories" and the y-axis "".
    protein, fat, fibre, carbo, and sugars versus calories. Give this plot the title "Five scatterplots". Be sure to label the x-axis "calories" and the y-axis "" again.


```{r}
# Construct the vector keep_vars +  extract the desired subset of UScereal
keep_vars <- c("calories", "protein", "fat",
               "fibre", "carbo", "sugars")
df <- UScereal[, keep_vars]

# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Use matplot() to generate an array of 2, 3, 4, then 5 scatterplots
matplot(df$calories, df[,c("protein","fat")], xlab = "calories", ylab = "")
title("Two scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre")], xlab = "calories", ylab = "")
title("Three scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre","carbo")], xlab = "calories", ylab = "")
title("Four scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre","carbo","sugars")], xlab = "calories", ylab = "")
title("Five scatterplots")
```

# How many words is too many?

Scatterplot arrays lose their utility if allowed to become too complex, either including too many plots, or attempting to include too many scatterplots on 1 set of axes. More generally, any data viz loses its utility if it becomes too complex.

**Wordclouds** presents words in varying sizes depending on frequency via `wordcloud()` called w/ a character vector of words + a 2nd numerical vector giving the # of times each word appears in the collection used to generate the wordcloud.

2 other useful arguments = `scale` = a 2-component numerical vector giving relative size of the largest + smallest words in the display + `min.freq` = only display words that occur at least this # of times in the collection w/ a default value = 3.

The wordcloud package is already loaded in your workspace.

    Use the table() function to create the variable mfr_table that tabulates the number of times each level of the Manufacturer variable appears in the Cars93 data frame.
    Use the wordcloud() function to display this manufacturer data, setting the scale argument to c(2, 0.25) to make the wordcloud fit in the display window.
    By default, the wordcloud() function shows only those words that appear 3 or more times. Use the min.freq argument to obtain a display with all Manufacturer values in the wordcloud.
    Use the table() function to create the variable model_table that tabulates the number of times each level of the Model variable appears in the Cars93 data frame.
    Use the wordcloud() function with the scale argument set to c(0.75, 0.25) and the min.freq argument set to display all Model values. Use the zoom feature in the 'Plots' window to see this wordcloud more clearly. Does it convey useful information?

```{r}
# Create table of manufacturer frequencies
mfr_table <- table(Cars93$Manufacturer)

# create word cloud to show all manufacturers
wordcloud(words = names(mfr_table), 
          freq = as.numeric(mfr_table), 
          scale = c(2,.25), 
          min.freq = 1)

# Create model_table of model frequencies
model_table <- table(Cars93$Model)

# Create the wordcloud of all model names with smaller scaling
wordcloud(words = names(model_table), 
          freq = as.numeric(model_table), 
          scale = c(0.75, 0.25), 
          min.freq = 1)
```

# The Anscombe quartet

**Anscombe quartet** = collection of 4 datasets that appear to be essentially identical on the basis of simple summary statistics (means + SDs) but the behavior of the 4 datasets is quite different which becomes immediately apparent when we plot them.

    Use the par() function to set up a two-by-two plot array.
    Using plot(), create 4 separate plots from the anscombe data frame:
        y1 vs. x1
        y2 vs. x2
        y3 vs. x3
        y4 vs. x4
```{r}
# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot alls y's vs x's
plot(anscombe$x1, anscombe$y1)
plot(anscombe$x2, anscombe$y2)
plot(anscombe$x3, anscombe$y3)
plot(anscombe$x4, anscombe$y4)
```

The point of this exercise is to illustrate how much more clearly we can see differences in datasets if we plot all of them w/ the *same* x and y ranges + also illustrates the utility of improving the x- and y-axis labels and of adding informative plot titles.


    Examine the range of x and y values from the previous four plots to determine a common range that covers the ranges of all four of these plots. Use integer values to keep things simple.
    Set up a two-by-two plot array using the par() function.
    Plot the y1 variable against the x1 variable using these common ranges, with x-axis label "x value" and y-axis label "y value", and use the main argument to add the title "First dataset".
    Repeat for the other three Anscombe data pairs, adding the appropriate titles.

```{r}
# Define common x and y limits for the four plots
xmin <- 4
xmax <- 19
ymin <- 3
ymax <- 13

# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot y1 vs. x1 with common x and y limits, labels & title
plot(anscombe$x1, anscombe$y1,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "First dataset")

# Do the same for the y2 vs. x2 plot
plot(anscombe$x2, anscombe$y2,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Second dataset")

# Do the same for the y3 vs. x3 plot
plot(anscombe$x3, anscombe$y3,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Third dataset")

# Do the same for the y4 vs. x4 plot
plot(anscombe$x4, anscombe$y4,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Fourth dataset")
```

# Using multiple plots to give multiple views of a dataset

Another useful application of multiple plot arrays besides comparison is presenting multiple related views of the same dataset.

Give 4 views of the same dataset: raw data values, a histogram of these data values, a density plot, and a normal QQ-plot.

Note that the MASS and car packages have been pre-loaded, making the geyser data and the truehist() and qqPlot() fuctions available for your use.
Use the par() function to set the mfrow parameter for a two-by-two plot array.
In the upper left, use the plot() function to show the values of the duration variable from the geyser dataset, using the main argument to specify the plot title as "Raw data".
In the upper right, use the truehist() function to generate a histogram of the duration data, using the main argument to give this plot the title "Histogram".
In the lower left, use the plot() and density() functions to display the 

```{r}
# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot the raw duration data
plot(geyser$duration, main = "Raw data")

# Plot the normalized histogram of the duration data
truehist(geyser$duration, main = "Histogram")

# Plot the density of the duration data
plot(density(geyser$duration), main = "Density")

# Construct the normal QQ-plot of the duration data
qqPlot(geyser$duration, main = "QQ-plot")
```

