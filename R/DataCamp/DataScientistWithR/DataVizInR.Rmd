---
title: "DataVizInR"
author: "Steve Newns"
date: "November 29, 2017"
output: html_document
---

```{r}
library(MASS)
library(car)
library(wordcloud)
```
`matplot()` can be used to easily generate a plot w/ several scatterplots on the same set of axes. By default, the points in these scatterplots are represented by the numbers 1 through n, where n = the total number of scatterplots included, but most of options available w/ `plot()` are also possible by specifying the appropriate arguments.

Set up a plot array w/ 4 of these multiple scatterplot displays, each including 1 more scatterplot than the previous one + judge for yourself how many scatterplots is too many.

    Use the par() function to set up the mfrow parameter to generate a two-by-two plot array.
    Use the matplot() function to construct a two-scatterplot display of
    protein and fat versus calories. Give this plot the title "Two scatterplots" using the title() function. Label the x-axis "calories" and the y-axis "" to get rid of the default y-axis label.
    protein, fat and fibre versus calories. Give this plot the title "Three scatterplots". Similarly, label the x-axis "calories" and the y-axis "".
    protein, fat, fibre and carbo versus calories. Give this plot the title "Four scatterplots". Again, label the x-axis "calories" and the y-axis "".
    protein, fat, fibre, carbo, and sugars versus calories. Give this plot the title "Five scatterplots". Be sure to label the x-axis "calories" and the y-axis "" again.


```{r}
# Construct the vector keep_vars +  extract the desired subset of UScereal
keep_vars <- c("calories", "protein", "fat",
               "fibre", "carbo", "sugars")
df <- UScereal[, keep_vars]

# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Use matplot() to generate an array of 2, 3, 4, then 5 scatterplots
matplot(df$calories, df[,c("protein","fat")], xlab = "calories", ylab = "")
title("Two scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre")], xlab = "calories", ylab = "")
title("Three scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre","carbo")], xlab = "calories", ylab = "")
title("Four scatterplots")

matplot(df$calories, df[,c("protein","fat","fibre","carbo","sugars")], xlab = "calories", ylab = "")
title("Five scatterplots")
```

# How many words is too many?

Scatterplot arrays lose their utility if allowed to become too complex, either including too many plots, or attempting to include too many scatterplots on 1 set of axes. More generally, any data viz loses its utility if it becomes too complex.

**Wordclouds** presents words in varying sizes depending on frequency via `wordcloud()` called w/ a character vector of words + a 2nd numerical vector giving the # of times each word appears in the collection used to generate the wordcloud.

2 other useful arguments = `scale` = a 2-component numerical vector giving relative size of the largest + smallest words in the display + `min.freq` = only display words that occur at least this # of times in the collection w/ a default value = 3.

The wordcloud package is already loaded in your workspace.

    Use the table() function to create the variable mfr_table that tabulates the number of times each level of the Manufacturer variable appears in the Cars93 data frame.
    Use the wordcloud() function to display this manufacturer data, setting the scale argument to c(2, 0.25) to make the wordcloud fit in the display window.
    By default, the wordcloud() function shows only those words that appear 3 or more times. Use the min.freq argument to obtain a display with all Manufacturer values in the wordcloud.
    Use the table() function to create the variable model_table that tabulates the number of times each level of the Model variable appears in the Cars93 data frame.
    Use the wordcloud() function with the scale argument set to c(0.75, 0.25) and the min.freq argument set to display all Model values. Use the zoom feature in the 'Plots' window to see this wordcloud more clearly. Does it convey useful information?

```{r}
# Create table of manufacturer frequencies
mfr_table <- table(Cars93$Manufacturer)

# create word cloud to show all manufacturers
wordcloud(words = names(mfr_table), 
          freq = as.numeric(mfr_table), 
          scale = c(2,.25), 
          min.freq = 1)

# Create model_table of model frequencies
model_table <- table(Cars93$Model)

# Create the wordcloud of all model names with smaller scaling
wordcloud(words = names(model_table), 
          freq = as.numeric(model_table), 
          scale = c(0.75, 0.25), 
          min.freq = 1)
```

# The Anscombe quartet

**Anscombe quartet** = collection of 4 datasets that appear to be essentially identical on the basis of simple summary statistics (means + SDs) but the behavior of the 4 datasets is quite different which becomes immediately apparent when we plot them.

    Use the par() function to set up a two-by-two plot array.
    Using plot(), create 4 separate plots from the anscombe data frame:
        y1 vs. x1
        y2 vs. x2
        y3 vs. x3
        y4 vs. x4
```{r}
# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot alls y's vs x's
plot(anscombe$x1, anscombe$y1)
plot(anscombe$x2, anscombe$y2)
plot(anscombe$x3, anscombe$y3)
plot(anscombe$x4, anscombe$y4)
```

The point of this exercise is to illustrate how much more clearly we can see differences in datasets if we plot all of them w/ the *same* x and y ranges + also illustrates the utility of improving the x- and y-axis labels and of adding informative plot titles.


    Examine the range of x and y values from the previous four plots to determine a common range that covers the ranges of all four of these plots. Use integer values to keep things simple.
    Set up a two-by-two plot array using the par() function.
    Plot the y1 variable against the x1 variable using these common ranges, with x-axis label "x value" and y-axis label "y value", and use the main argument to add the title "First dataset".
    Repeat for the other three Anscombe data pairs, adding the appropriate titles.

```{r}
# Define common x and y limits for the four plots
xmin <- 4
xmax <- 19
ymin <- 3
ymax <- 13

# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot y1 vs. x1 with common x and y limits, labels & title
plot(anscombe$x1, anscombe$y1,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "First dataset")

# Do the same for the y2 vs. x2 plot
plot(anscombe$x2, anscombe$y2,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Second dataset")

# Do the same for the y3 vs. x3 plot
plot(anscombe$x3, anscombe$y3,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Third dataset")

# Do the same for the y4 vs. x4 plot
plot(anscombe$x4, anscombe$y4,
     xlim = c(xmin, xmax),
     ylim = c(ymin, ymax),
     xlab = "x value", ylab = "y value",
     main = "Fourth dataset")
```

# Using multiple plots to give multiple views of a dataset

Another useful application of multiple plot arrays besides comparison is presenting multiple related views of the same dataset.

Give 4 views of the same dataset: raw data values, a histogram of these data values, a density plot, and a normal QQ-plot.

Note that the MASS and car packages have been pre-loaded, making the geyser data and the truehist() and qqPlot() fuctions available for your use.
Use the par() function to set the mfrow parameter for a two-by-two plot array.
In the upper left, use the plot() function to show the values of the duration variable from the geyser dataset, using the main argument to specify the plot title as "Raw data".
In the upper right, use the truehist() function to generate a histogram of the duration data, using the main argument to give this plot the title "Histogram".
In the lower left, use the plot() and density() functions to display the 

```{r}
# Set up a two-by-two plot array
par(mfrow = c(2,2))

# Plot the raw duration data
plot(geyser$duration, main = "Raw data")

# Plot the normalized histogram of the duration data
truehist(geyser$duration, main = "Histogram")

# Plot the density of the duration data
plot(density(geyser$duration), main = "Density")

# Construct the normal QQ-plot of the duration data
qqPlot(geyser$duration, main = "QQ-plot")
```

# Constructing and displaying layout matrices

Can set up a **layout matrix** to be used w/ `layout()` in creating a plot array. Think of the layout matrix as the plot pane, where 0 = empty space + other #'s represent the plot #, which is determined by the sequence of visualization function calls. For example, a 1 in the layout matrix = the viz that was called 1st, a 2 = plot of 2nd viz call, etc. Create your own 3 x 2 layout matrix w/ `c()` to concatenate numbers into vectors that will form the rows of the matrix.

Then use `matrix()` to convert these rows into a matrix + apply `layout()` to set up the desired plot array. The **convenience function** `layout.show()` can then be used to verify the plot array has the shape you want.


    Using the matrix() function, create a matrix called layoutMatrix with three rows and two columns:
        the first row designates an empty plot to the left and plot 1 to the right.
        the second row designates plot 2 to the left and an empty plot to the right.
        the third row designates an empty plot to the left and plot 3 to the right.
    Use the layout() function to set up the desired plot array.
    Use the layout.show() function to show the arrangement of all three plots.

```{r}
# Use the matrix function to create a matrix with three rows and two columns
layoutMatrix <- matrix(
  c(0, 1,
    2, 0,
    0, 3), byrow = T, nrow = 3)

# Call the layout() function to set up the plot array
layout(layoutMatrix)

# Show where the three plots will go 
layout.show(n=3)
```

`layout()` is a little harder than setting up plot arrays w/ `mfrow` parameter, but it is a lot more flexible.

# Creating a triangular array of plots

Use layoutMatrix to give 3 different views of `whiteside` w/ 1st plot on upper right of plot array = the relationship of `Gas` + `Temp` using data where `Insul = "Before"`, 2nd plot in center left of plot array = relationship of same 2 variables using all data, + 3rd plot on lower left of plot array = relationship using data where `Insul = "After"`.

The primary motivation for this exercise is that it is not possible to construct a plot array in this format using the mfrow parameter, since the array is not rectangular.

The layout matrix you set up in the previous is available in your workspace as layoutMatrix. The whiteside data frame is already available in your workspace as well.

    Call the layout() function on layoutMatrix to set up the plot array.
    Construct a vector indexB that points to only those records with the Insul value "Before" and a vector indexA that points to only those records with the Insul value "After".
    Plot the Gas versus Temp values from the indexB data in the upper right plot in your array, using the y-axis limits c(0, 8). Give this plot the title "Before data only".
    Plot the Gas versus Temp values from the complete dataset in the center left plot, using the same y-axis limits as the first plot. Give this plot the title "Complete dataset".
    Plot the Gas versus Temp values from the indexA data in the lower right plot, again using the same y-axis limits. Give this plot the title "After data only".

```{r}
# Set up the plot array via layout(layoutMatrix) call to set up the plot array.
layout(layoutMatrix)

# Construct vectors indexB and indexA
indexB <- which(whiteside$Insul == "Before")
indexA <- which(whiteside$Insul == "After")

# Create plot 1 and add title
plot(whiteside$Temp[indexB], whiteside$Gas[indexB],
     ylim = c(0,8))
title("Before data only")

# Create plot 2 and add title
plot(whiteside$Temp, whiteside$Gas,
     ylim = c(0,8))
title("Complete dataset")

# Create plot 3 and add title
plot(whiteside$Temp[indexA], whiteside$Gas[indexA],
     ylim = c(0,8))
title("After data only")
```

# Creating arrays with different sized plots

Besides creating non-rectangular arrays, `layout()` can be used to create plot arrays w/ different sized component plots, something else not possible via `par()`'s `mfrow` parameter.

Create standard scatterplot of `zn` vs. `rad` from `Boston` as a smaller plot in the upper left, w/ a larger sunflower plot of the same data in the lower right.

The Boston data frame in the MASS package is already available in your workspace.

    Using the c() function:
    Create the three-element vector row1 with values (1, 0, 0).
    Create the three-element vector row2 with values (0, 2, 2).
    Combine the first vector with two copies of the second vector into layoutVector, a vector of length 9.
    Using the matrix() function, convert layoutVector into the 3-by-3 matrix layoutMatrix whose first row is row1 and whose second and third rows are row2.
    Use the layout() function with layoutMatrix to configure a two-element plot array.
    In the first (smaller) plot, create a standard scatterplot of the zn variable versus the rad variable from the Boston data frame.
    In the second (larger) plot, create a sunflower plot using the sunflowerplot() function and the same variables.

```{r}
# Create row1, row2, and layoutVector
row1 <- c(1,0,0)
row2 <- c(0,2,2)
layoutVector <- c(row1,row2,row2)

# Convert layoutVector into layoutMatrix
layoutMatrix <- matrix(layoutVector, byrow = T, nrow = 3)

# Set up the plot array
layout(layoutMatrix)

# Plot scatterplot
plot(Boston$rad, Boston$zn)

# Plot sunflower plot
sunflowerplot(Boston$rad, Boston$zn)
```

