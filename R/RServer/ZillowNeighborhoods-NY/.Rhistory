geom_smooth(aes(displ, hwy, linetype = drv, color = drv))
ggplot(mpg) +
geom_smooth(aes(displ, hwy, group = drv))
ggplot(mpg, aes(displ, hwy, linetype = drv)) +
geom_point() +
geom_smooth()
ggplot(mpg, aes(displ, hwy, linetype = drv, color = drv) +
geom_point() +
geom_smooth()
ggplot(mpg, aes(displ, hwy, linetype = drv, color = drv)) +
geom_point() +
geom_smooth()
ggplot(mpg, aes(displ, hwy, linetype = drv, color = drv)) +
geom_point() +
geom_smooth()
ggplot(mpg, aes(displ, hwy) +
# override possible global color for the point layer
geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy) +
# override possible global color for the point layer
geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
geom_point(aes(color = class))
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
#geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
#geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(data = filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy)) +
# override possible global color for the point layer
geom_point(aes(color = class)) +
# subset data for smooth line for this layer only
geom_smooth(data = filter(mpg, class == 'subcompact'), se = FALSE)
ggplot(mpg, aes(displ, hwy, color = drv)) +
geom_point() +
geom_smooth(se = FALSE)
library(tidyverse)
install.packages(c("nycflights13", "gapminder", "Lahman"))
glimpse(mpg)
library(ggplot2)
ggplot(mpg, aes(displ, hwy, color = drv)) +
geom_point() +
geom_smooth(se = FALSE)
?geom_smooth()
ggplot(mpg, aes(displ, hwy, color = drv)) +
geom_point() +
geom_smooth(se = F)
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_smooth(se = F)
ggplot(mpg) +
geom_smooth(aes(displ, hwy, group = drv))
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_smooth(se = F, group = drv)
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_smooth(se = F, aes(group = drv))
ggplot(mpg, aes(displ, hwy, color = drv)) +
geom_point() +
geom_smooth(se = F, aes(group = drv))
ggplot(mpg, aes(displ, hwy, color = drv)) +
geom_point() +
geom_smooth(se = F)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv)) +
geom_smooth(se = F)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv)) +
geom_smooth(se = F, aes(linetype = drv))
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv))
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), color = 'white')
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), color = drv)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv), color = 'black')
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv))#
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv))#, color = 'black')
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), pch = 21)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), pch = 21, color = 'white')
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), pch = 21, color = 'white', size = 3)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), pch = 21, color = 'white', size = 5)
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(fill = drv), pch = 21, color = 'white', size = 5, stroke = 3)
ggplot(diamonds) +
geom_bar(aes(cut))
ggplot(diamonds) +
stat_count(aes(cut))
ggplot(demo) +
geom_bar(aes(cut, freq), stat = "identity")
demo <- tribble(
~cut,         ~freq,
"Fair",       1610,
"Good",       4906,
"Very Good",  12082,
"Premium",    13791,
"Ideal",      21551
)
ggplot(demo) +
geom_bar(aes(cut, freq), stat = "identity")
ggplot(diamonds) +
geom_bar(aes(cut, ..prop.., group = 1))
ggplot(diamonds) +
stat_summary(
aes(cut, depth),
fun.ymin = min,
fun.ymax = max,
fun.y = median
)
?stat_summary
?geom_pointrange
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth))
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth),
fun.ymin = min,
fun.ymax = max,
fun.y = median
)
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth),
ymin = min,
ymax = max#,
#fun.y = median
)
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth),
ymin = min,
ymax = max,
y = median
)
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth),
ymin = min,
ymax = max,
x = median
)
ggplot(diamonds) +
geom_pointrange(
aes(cut, depth),
ymin = min,
ymax = max
)
ggplot(diamonds, aes(cut, depth)) +
geom_pointrange(
ymin = min,
ymax = max
)
ggplot(diamonds, aes(cut, depth)) +
geom_pointrange(
ymin = min(depth),
ymax = max(depth)
)
ggplot(diamonds, aes(cut, depth)) +
geom_pointrange(
ymin = min(diamonds$depth),
ymax = max(diamonds$depth)
)
ggplot(diamonds) +
geom_pointrange(stat = 'identity',
aes(cut, depth),
fun.ymin = min,
fun.ymax = max,
fun.y = median
)
ggplot(diamonds) +
geom_pointrange(stat = 'summary',
aes(cut, depth),
fun.ymin = min,
fun.ymax = max,
fun.y = median
)
?geom_col
?stat_smooth
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, y = ..prop..))
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
?geom_bar
library(RevoScaleR)
library(tidyverse)
nyc_xdf <- RxXdfData("C:/Users/Nimz/Dropbox/yellow_tripdata_2016.xdf")
rxGetInfo(nyc_xdf, getVarInfo = T, numRows = 10)
library(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- "2012-12-31 16:12:11"
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
library(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- "2012-12-31 16:12:11"
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
pickup_hour
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_hour
library(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- "2012-12-31 16:12:11"
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
pickup_hour
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_hour
pickup_datetime <- "2012-12-31 16:12:11"
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow
pickup_hour
xforms <- function(data) {
# transformation function to extract date + time features
require(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- ymd_hms(data$tpep_pickup_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
dropoff_datetime <- ymd_hms(data$tpep_dropoff_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
dropoff_hour <- addNA(cut(hour(dropoff_datetime), cut_levels))
dropoff_dow <- factor(wday(dropoff_datetime), levels = 1:7, labels = weekday_labels)
levels(dropoff_hour) <- hour_labels
# replace values in data w/ new values from above
data$pickup_hour <- pickup_hour
data$pickup_dow <- pickup_dow
data$dropoff_hour <- dropoff_hour
data$dropoff_dow <- dropoff_dow
# create duration
data$trip_duration <- as.integer(as.duration(dropoff_datetime - pickup_datetime))
}
xforms <- function(data) {
# transformation function to extract date + time features
require(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- ymd_hms(data$tpep_pickup_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
dropoff_datetime <- ymd_hms(data$tpep_dropoff_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
dropoff_hour <- addNA(cut(hour(dropoff_datetime), cut_levels))
dropoff_dow <- factor(wday(dropoff_datetime), levels = 1:7, labels = weekday_labels)
levels(dropoff_hour) <- hour_labels
# replace values in data w/ new values from above
data$pickup_hour <- pickup_hour
data$pickup_dow <- pickup_dow
data$dropoff_hour <- dropoff_hour
data$dropoff_dow <- dropoff_dow
# create duration
data$trip_duration <- as.integer(as.duration(dropoff_datetime - pickup_datetime))
data
}
xforms <- function(data) {
# transformation function to extract date + time features
require(lubridate)
weekday_labels <- c("Sun","Mon","Tue","Wed","Thu","Fri","Sat")
cut_levels <- c(1,5,9,12,16,18,22)
hour_labels <- c("1-5AM","5-9AM","9-12PM","12-4PM","4-6PAM","6-10PM","10-1AM")
pickup_datetime <- ymd_hms(data$tpep_pickup_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
pickup_hour <- addNA(cut(hour(pickup_datetime), cut_levels))
pickup_dow <- factor(wday(pickup_datetime), levels = 1:7, labels = weekday_labels)
levels(pickup_hour) <- hour_labels
dropoff_datetime <- ymd_hms(data$tpep_dropoff_datetime, tz = "UTC")
# bin the hour of a datetime --> cut levels tells us what 2 hour cutoff an hour falls w/in
# make it NA if it falls between 10PM to 1AM
dropoff_hour <- addNA(cut(hour(dropoff_datetime), cut_levels))
dropoff_dow <- factor(wday(dropoff_datetime), levels = 1:7, labels = weekday_labels)
levels(dropoff_hour) <- hour_labels
# replace values in data w/ new values from above
data$pickup_hour <- pickup_hour
data$pickup_dow <- pickup_dow
data$dropoff_hour <- dropoff_hour
data$dropoff_dow <- dropoff_dow
# create duration
data$trip_duration <- as.integer(as.duration(dropoff_datetime - pickup_datetime))
#return data
data
}
col_classes <- c('VendorID' = "factor",
'tpep_pickup_datetime' = "character",
'tpep_dropoff_datetime' = "character",
'passenger_count' = "integer",
'trip_distance' = "numeric",
'pickup_longitude' = "numeric",
'pickup_latitude' = "numeric",
'RateCodeID' = "factor",
'store_and_fwd_flag' = "factor",
'dropoff_longitude' = "numeric",
'dropoff_latitude' = "numeric",
'payment_type' = "factor",
'fare_amount' = "numeric",
'extra' = "numeric",
'mta_tax' = "numeric",
'tip_amount' = "numeric",
'tolls_amount' = "numeric",
'improvement_surcharge' = "numeric",
'total_amount' = "numeric",
'u' = "numeric")
# load in 1st 1000 rows from january as a test data frame before deploying code to big data in RevoScaleR
jan <- read.csv(unz("yellow_tripsample_2016-01.zip", "yellow_tripsample_2016-01.csv"), nrow = 1000,
colClasses = col_classes)
glimpse(jan)
setwd("C:/Users/Nimz/Dropbox/DataScienceMasters/R/RServer")
col_classes <- c('VendorID' = "factor",
'tpep_pickup_datetime' = "character",
'tpep_dropoff_datetime' = "character",
'passenger_count' = "integer",
'trip_distance' = "numeric",
'pickup_longitude' = "numeric",
'pickup_latitude' = "numeric",
'RateCodeID' = "factor",
'store_and_fwd_flag' = "factor",
'dropoff_longitude' = "numeric",
'dropoff_latitude' = "numeric",
'payment_type' = "factor",
'fare_amount' = "numeric",
'extra' = "numeric",
'mta_tax' = "numeric",
'tip_amount' = "numeric",
'tolls_amount' = "numeric",
'improvement_surcharge' = "numeric",
'total_amount' = "numeric",
'u' = "numeric")
# load in 1st 1000 rows from january as a test data frame before deploying code to big data in RevoScaleR
jan <- read.csv(unz("yellow_tripsample_2016-01.zip", "yellow_tripsample_2016-01.csv"), nrow = 1000,
colClasses = col_classes)
glimpse(jan)
head(xforms(jan))
head(xforms(jan))
head(rxDataStep(jan, transformFunc = xforms, transformPackages = "lubridate"))
nyc_xdf <- RxXdfData("C:/Users/Nimz/Dropbox/yellow_tripdata_2016.xdf")
# check how long it took as well
st <- Sys.time()
rxDataStep(inData = nyc_xdf, outFile = nyc_xdf, overwrite = T, transformFunc = xforms, transformPackages = "lubridate")
Sys.time() - st
rxs1 <- rxSummary(~ pickup_hour, pickup_dow, trip_duration, nyx_xdf)
rxs1 <- rxSummary(~ pickup_hour + pickup_dow + trip_duration, nyx_xdf)
rxs1 <- rxSummary(~ pickup_hour + pickup_dow + trip_duration, nyc_xdf)
rxs1
rxs1 <- lapply(rxs1$categorical, function(x) cbind(x, prop = round(prop.table(x$Counts), 2)))
rxs1
rxs1 <- rxSummary(~ pickup_hour + pickup_dow + trip_duration, nyc_xdf)
' Name          Mean     StdDev   Min      Max      ValidObs MissingObs
trip_duration 956.5004 9256.298 -8018875 10764064 3467953  0
Category Counts for pickup_hour
Number of categories: 7
Number of valid observations: 3467953
Number of missing observations: 0
pickup_hour Counts
1-5AM       190066
5-9AM       531661
9-12PM      488519
12-4PM      672289
4-6PAM      397188
6-10PM      805985
10-1AM      382245
Category Counts for pickup_dow
Number of categories: 7
Number of valid observations: 3467953
Number of missing observations: 0
pickup_dow Counts
Sun        463950
Mon        446388
Tue        483912
Wed        497739
Thu        520793
Fri        532177
Sat        522994
> '
# see numerical summary for numerical variable trip_duration and counts for categorical variables
# add col for proportions next to counts (apply only to categorical variables in the XDF object)
rxs1$categorical <- lapply(rxs1$categorical, function(x) cbind(x, prop = round(prop.table(x$Counts), 2)))
rxs1
rxs2 <- rxSummary(~ pickup_hour:pickup_dow, nyc_xdf)
rxs2
rxs2 <- rxSummary(~ pickup_dow:pickup_hour, nyc_xdf)
rxs2
rxs2 <- tidyr::spread(rsx2$categorical[[1]], key = "pickup_hour", value = "Counts")
rxs2
rxs2 <- rxSummary(~ pickup_dow:pickup_hour, nyc_xdf)
rxs2
rxs2 <- tidyr::spread(rxs2$categorical[[1]], key = "pickup_hour", value = "Counts")
rxs2
rxs2[,1]
row.names(rxs2)
row.names(rxs2) <- rxs2[,1]
rxs2
rxs2[,-1]
rxs2[,-1]
rxs2 <- as.matrix(rxs2[,-1])
rxs2
type(rxs2)
class(rxs2)
levelplot
?levelplot
prop.table(rxs2)
prop.table(rxs2, 2)
levelplot(prop.table(rxs2, 2), cuts = 4, xlab = "", ylab = "", main == "Distribution of Taxis by Day of Week")
library(rgeos)
library(sp)
library(maptools)
setwd("C:/Users/Nimz/Dropbox/DataScienceMasters/R/RServer/ZillowNeighborhoods-NY")
nyc_shape <- readShapePoly("ZillowNeighborhoods-NY.shp")
mht_shape - subset(nyc_shape, str_detect(CITY, "New York City - Manhatten"))
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City - Manhatten"))
library(tidyverse)
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City - Manhatten"))
library(stringr)
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City - Manhatten"))
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City - Manhattan"))
mht_shape$data$id
mht_shape@data$id
nyc_shape <- readShapePoly("ZillowNeighborhoods-NY.shp")
# many programming languages have APIs for reading shape files (popular format for strong GIS info)
# subset shape file to only info about Manhattan
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City - Manhattan"))
# see what sort of information is in there.
mht_shape@data$id
nyc_shape <- readShapePoly("ZillowNeighborhoods-NY.shp")
nyc_shape
mht_shape <- subset(nyc_shape, str_detect(CITY, "New York City-Manhattan"))
mht_shape
mht_shape@data$id
mht_shape@data
mht_shape@data
mht_shape@data$NAME
mht_shape@data$id <- as.character(mht_shape@data$NAME)
mht_shape
mht_shape@data
?fortify
gBuffer(
?gBuffer
?gBuffer
?gBuffer
mht_points <- fortify(gBuffer(mht_shape, byid = T, width = 0), region = "NAME")
mht_points
mht_shape@data
mht_df <- inner_join(mht_points, mht_shape@data, by = "id")
mht_df
head(mht_df)
library(dplyr)
mht_center <- mht_df %>%
group_by(id) %>%
summarize(long = median(long), lat = median(lat))
head(mht_center)
?geom_path
?coord_equal
library(ggrepel)
ggplot(mht_df, aes(long, lat, fill = id)) +
geom_polygon() +
geom_path(color = "white") +      # connect observations in order they appear w/ white border
coord_equal() +                   # use fixed scale coordinate system
theme(legend.position = "none") + # remove legend
geom_text_repel(aes(label = id), data = mht_center, size = 2)
